= Base format =

Map format: tmx

Editor: 

[[File:screenshot-map-editor.png]]

tmx map editor (see lib tiled): http://www.mapeditor.org/

Support into the server: xml with pre-calculate the collision/water zone

Support into the client: lib tiled for QGraphicView or QML

The spawn point is useless, when map change, your are teleported at the middle. If you are blocked ask to the administrator, command to random teleport to low level village will be implanted too.

= Map content =
== General properties ==
Why not all into the xml? To minise the number of file.
* '''type:''' indoor, outdoor, cave, and into the map/music.xml:
<pre><list>
	<!-- can be overwriten into the map.xml, keep empty if nothing -->
	<map type="city">music/city.ogg</map>
	<map type="indoor">music/indoor.ogg</map>
	<map type="outdoor">music/outdoor.ogg</map>
</list></pre>
* '''ambiance:''' the ambiance name (define step sound, background sound, ...)
* '''zone:''' the zone name (found into zone folder with [name].xml)
The '''0,0''' is at '''left and top''' for this protocol.

== Xml file ==
 &lt;map type="outdoor" backgroundsound="toto.ogg" zone="test"&gt;
        &lt;name lang="en"&gt;English name&lt;/name&gt;
        &lt;name lang="fr"&gt;Nom fran√ßais&lt;/name&gt;
        &lt;grass&gt;
               &lt;monster id="1" minLevel="3" maxLevel="4" luck="20" /&gt;
               &lt;monster id="2" level="2" luck="80" /&gt;
        &lt;/grass&gt;
 &lt;/map&gt;
the balise grass can be wather, cave.

== Layer ==
* '''WalkBehind:''' do player image behind this layer
* '''Collisions:''' the player have collision with this layer
* '''Water:''' The player have collision with this layer, but can swim it
* '''Walkable:''' Can walk on this layer, this the bottom layer
* '''LedgesRight:''' border to jump, the player will jump left to right
* '''LedgesLeft:''' border to jump, the player will jump right to left
* '''LedgesBottom:''' border to jump, the player will jump up to down
* '''LedgesTop:''' border to jump, the player will jump up to top
* '''Grass:''' grass, where have random chance to find a monster
* '''Dirt:''' dirt where plant can grow

== Object ==
It's on layer Object with name: "''Object''", Name: what you want

'''[bot]'''
* Type: bot
* file: Xml script, see: [[Bot format]]
* id: the id into the bot file
* lookAt: left, right, top, bottom
* skin: you skin name

== Teleportation ==
It's layer Object with name "''Moving''", only visible on map editor.

* '''Warning:''' For the protocol, it's like you walk over the teleport tile, but if you continue to press the key, not send interruption (keep last direction = before distance + after distance). If you do 3 step down before pass a door, and 2 step down after, the client send 5 step down (the server calculate the tp).
* '''Note:''' If you are tp on a teleporter, this tp do nothing, you need quit and re-go on it to activate it. Usage of if (not while), to improve the performance, and have more flexible game.
* File name of the map can be without .tmx at the end to gain space

'''[teleport on push]'''
* Type: teleport on push
* map: [file name]
* x: coordinates in x
* y: coordinates in y

'''[teleport on it]'''
* Type: teleport on it (when the player is fully on it)
* map: [file name]
* x: coordinates in x
* y: coordinates in y

'''[border]'''
* Type: border-top, border-bottom, border-left, border-right
* map: [file name]
* Need correspond with the other border on the corresponding map

'''[door]'''
* Type: door 
* map: [file name]
* x: coordinates in x
* y: coordinates in y

'''[rescue]'''
* Type: set the point to respawn if the monsters at the next heal.

'''[bot spawn]'''
* Type: set the point to spawn bot

=== Conditionnal teleportation ===
This apply on: '''teleport on push''', '''teleport on it''', '''door'''

Just add the properties:
* condition-file: path relative to the map
* condition-id: id

Condition file:
<pre><conditions>
	<condition id="1" type="quest" quest="1">
		<blockedtext><![CDATA[You have not done the quest <b>The beginner's rod</b>]]></blockedtext>
	</condition>
	<condition id="2" type="item" item="1">
		<blockedtext><![CDATA[You have not an <b>Potion</b> to open the door]]></blockedtext>
	</condition>
	<condition id="3" type="clan"><!--if the clan have captured the area-->
		<blockedtext><![CDATA[Your clan don't own the area]]></blockedtext>
	</condition>
	<condition id="4" type="fightBot" fightBot="1">
		<blockedtext><![CDATA[You have don't win agains the first bot]]></blockedtext>
	</condition>
</conditions></pre>

== Animation ==
The animation apply on an tile, to have it define properties with name: '''''animation''''' and value: '''''500ms;4frames''''' (where 500 and 4 is an exemple).

= Implementation =
For each map it use into memory:
* QHash<QString,Map_final> + QHash<quint32,Map_final *>, to have indexed search
* bool size * width * height * 2 (walkable + water)
* 4 pointer + 4 * 2 * quint32 for the border
* pointer size * near map
* QHash<quint32,Map_final *> * (number of door + tp)
* QString for the map file name, to have the reverse
* size of quint16 * 2 for width + height
* QHash<QString,QVariant> * number of property, to keep the current map property
* size of quint32 for the group
* size of ClientMapManagement pointer by the number of player on this map

Then for 50 player on the map, 8 map near, 40x40 size, on 64Bits computer, with 5 doors:
* 16*4 + 8 = 72B
* 8*40*40*2= 25.6 KB
* 8*4 + 4*2*4 = 64B
* 8*8 = 64B
* (4+8)*5 = 60B
* 16*4 = 64B
* 2*2 = 4B
* ~1KB
* 2B
* 8*50 = 400B
The total is near than: 730 for minor data + 1KB for property + 25 KB for tile cache = 27KB (92% by tile cache, tile cache can be compressed but it will use more cpu)
