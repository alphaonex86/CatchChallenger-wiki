= Base format =

Map format: tmx

Editor: tmx map editor (see lib tiled)

Support into the server: xml with pre-calculate the collision/water zone

Support into the client: lib tiled for QGraphicView or QML

The spawn point is useless, when map change, your are teleported at the middle. If you are blocked ask to the administrator, command to random teleport to low level village will be implanted too.

= Map content =
== General map content ==
Here described the map format, into the tmx
* '''type''': city, outside, cave, inside, arena
* '''dayMonster''': 78,90,15-24;79,10,20-24; (each monster separated by ";", and as format: id, % of chance, level)
* '''nightMonster''': 78,90,15-24;79,10,20-24; (each monster separated by ";", and as format: id, % of chance, level)
* '''waterMonster''': 78,90,15-24;79,10,20-24; (each monster separated by ";", and as format: id, % of chance, level)
* '''wildProbability''': 10

The object and layer is described above.

The '''0,0''' is at '''left and top''' for this protocol.
The size should be egal as '''40,40'''

== Layer ==
* '''WalkBehind:''' do player image behind this layer
* '''Collisions:''' the player have collision with this layer
* '''Water:''' The player have collision with this layer, but can swim it
* '''Walkable:''' Can walk on this layer, this the bottom layer
* '''LedgesRight:''' border to jump, the player will jump left to right
* '''LedgesLeft:''' border to jump, the player will jump right to left
* '''LedgesDown:''' border to jump, the player will jump up to down
* '''Grass:''' grass, where have random chance to find a monster

== Object ==
It's on layer Object with name: Object, Name: what you want

'''[bot-text]'''
* Type: bot-text
* text: Xml script
* Optional:
* move: x,y;x,y;...;x,y
* look_you: false (default: true)

'''[sign]'''
* Type: sign
* text: Xml text

== Teleportation ==
It's layer Object with name "Tp", only visible on map editor:

'''[teleport on push]'''
* Type: teleport on push
* map: [map name]
* x, y: cordon

'''[teleport on it]'''
* Type: teleport on it (when the player is fully on it)
* map: [map name]
* x, y: cordon

'''[border]'''
* Type: border-top, border-bottom, border-left, border-right
* map: [map name]
* Need correspond with the other border on the corresponding map

'''[door]'''
* Type: door 
* map: [file name]
* x & y: cordon on the new map

= Implementation =
For each map it use into memory:
* QHash<QString,Map_final> + QHash<quint32,Map_final *>, to have indexed search
* bool size * width * height * 2 (walkable + water)
* 4 pointer + 4 * 2 * quint32 for the border
* pointer size * near map
* QHash<quint32,Map_final *> * (number of door + tp)
* QString for the map file name, to have the reverse
* size of quint16 * 2 for width + height
* QHash<QString,QVariant> * number of property, to keep the current map property
* size of quint32 for the group
* size of ClientMapManagement pointer by the number of player on this map

Then for 50 player on the map, 8 map near, 40x40 size, on 64Bits computer, with 5 doors:
* 16*4 + 8 = 72B
* 8*40*40*2= 25.6 KB
* 8*4 + 4*2*4 = 64B
* 8*8 = 64B
* (4+8)*5 = 60B
* 16*4 = 64B
* 2*2 = 4B
* ~1KB
* 2B
* 8*50 = 400B
The total is near than: 730 for minor data + 1KB for property + 25 KB for tile cache = 27KB (92% by tile cache, tile cache can be compressed but it will use more cpu)
