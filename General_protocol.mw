= Protocol content =
The used encoding is the unicode (utf16), where each char is encoded into 16Bits in big endian.

Firstly query type 8Bits to the first type and if needed 32Bits for the sub type, query number as short unsigned 8Bits (if query with reply), after the specific part.

= Cutting packet =
The tpc/ip protocol split the packet into lot of small packet. Warning, you need recompose the query.

= Order type =
== General ==
query client -> server with reply
* '''020001''' Protocol
* '''020002''' Get first data and send the login
* '''02000C''' Send datapack file list

query client -> server without reply
* '''40''' Send position + direction '''''(Fast)'''''
* '''41''' Reply to server query
* '''420003''' Chat
* '''42000A''' Add players info to watch
* '''42000B''' Remove players info to watch

query server -> client without reply
* '''C0''' Position + direction of other player '''''(Fast)'''''
* '''C1''' Reply to client query
* '''C20001''' Random seed list (with type to group by random seed list)
* '''C20002''' update of the player info
* '''C20003''' update file
* '''C20005''' chat
* '''C20008''' kicked/ban and reason
* '''C20009''' Player number
* '''C2000A''' Remove all other player on the map

== Specific to catchchallenger ==
query client -> server with reply
* '''020006''' Invite to the trade + push new object to the trade (with sell/buy too)
* '''020008''' Give bot craft recipe and object, and define the price + taxe

query client -> server without reply
* '''420004''' Fight attack/object used
* '''420005''' Usage of object

query server -> client with reply
* '''800001''' Battle request

= Latency =
* All the query with reply is identified by return code, then multiple query ca&n be send, it will never be blocking.
* Never ask the server reply because the reply is based on the random. '''A random list is used''' (and send by the server to the client), and both '''client and server do the calculate''' (minimize bandwidth, and not slow down)
* '''Send the previous step do and new direction'''. Then the server can check all move into one direction (more fast), and the request on the network is grouped. The client when receive the other player move, put the other player at the good position, and do moving at the right direction. With this, if latency is < a ms to do a step is always invisible. And if latency < at time to do all the step into a direction, is invisible too
* All the network traffic shouldn't be instant, then latency can be added to '''compress the data'''. Very useful because this protocol have high level of compression.
* All heavy '''task is isolated into a thread''' to not slow down the quick task

= Map position/move =
All is done to have multiple algorithm into the server, you can calculate that's by chunk of map, by map, or other way.

= Usage into other game =
[[File:catchchallenger-base-into-other-game.png]]
See: [[Other game usage]]

= Compression =
At the protocole supported or not reply, the server will send too the compression used, chunk size, and compression level. After this, the compression switch to the compression. The compression can be none.

The compression can be:
* Zlib: To save bandwidth at exchange of cpu
* Gzip: like Zlib but better ratio, and use more cpu
* lz4 by [[Lz4CompressionTcpSocket for Qt]]: Have very small cpu overhead, but worse compression ratio than zlib/gzip, lz4hc use few more cpu but remain with worse compression ratio than zlib/gzip.
* None: No compression overhead, but some query can use lot of bandwidth

It's compression for QTcpSocket/QSslSocket, and this compression can be hot added/removed. This class are adapted to streaming, that's: that's mean infinity volume, random data append, data re-composition, the data send at the compression is directly compressed and send (no wait more data to send). It's perfect to real time communication.

See too: [[Quick Benchmark: Gzip vs Bzip2 vs LZMA vs XZ vs LZ4 vs LZO]]
