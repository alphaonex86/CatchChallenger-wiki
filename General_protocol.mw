= Protocol content =
The protocol is binary protocol.
For the string: The encoding is the unicode (utf16) in big endian.

= Cutting packet =
The tpc/ip protocol split the packet into lot of small packet. Warning, you need recompose the query.

= Messages composition =
{| class="wikitable" style="text-align: center; font-size: 85%; width: auto; table-layout: fixed;"
| style="background: #90ff90; color: black;" | Main code type (8Bits)
| style="background: #ffcc00; color: black;" | Sub code type (16Bits, optional)
| Query number (8Bits, optional)
| style="background: #77eeFF; color: black;" | Packet size (for packet without fixed size)
| Packet content
|}

{{note}}: The packet size definition can varies:
* '''0x01:''' Mode small: Packet size with: XX if for <255 message size, 00XXXX is for <64KB size, 0000XXXXXXXX if for the rest. (Interesting for raw protocol for 4x packet < 255Bytes than <64KB)
* '''0x02:''' Mode big: Packet size with: 00XX if for <255 message size, XXXX is for <64KB size, 0000XXXXXXXX if for the rest. (Interesting for raw protocol for 4x packet < 255Bytes than <64KB)
Choose do by server at the [[Base_protocol_messages#020001|protocol initialization]].

The size is not calculated on variable into message, because it will be call lot of, to recompose the message, then big lost of performance.

= Messages type =
* [[Base protocol messages]]
* [[CatchChallenger specific messages]]

= Latency =
* All the query with reply is identified by return code, then multiple query ca&n be send, it will never be blocking.
* Never ask the server reply because the reply is based on the random. '''A random list is used''' (and send by the server to the client), and both '''client and server do the calculate''' (minimize bandwidth, and not slow down). See the [[Server/Client_link#Random list|random list]].
* '''Send the previous step do and new direction'''. Then the server can check all move into one direction (more fast), and the request on the network is grouped. The client when receive the other player move, put the other player at the good position, and do moving at the right direction. With this, if latency is < a ms to do a step is always invisible. And if latency < at time to do all the step into a direction, is invisible too
* All the network traffic shouldn't be instant, then latency can be added to '''compress the data'''. Very useful because this protocol have high level of compression.
* All heavy '''task is isolated into a thread''' to not slow down the quick task
[[File:random-list.png]]
The client NEVER wait a reply.

= Map position/move =
All is done to have multiple algorithm into the server, you can calculate that's by chunk of map, by map, or other way.

The choice is do of display number of player will depends of the max player. To minimize into 8Bits the number if max player < 255, else 16Bits.

The coordinates is limited to 8Bits. And map map into utf8, with 8Bits of size header (max 255 bytes).

= Other limit =
The pseudo is too into UTF8, max 255 bytes.
The skin path is too into UTF8, max 255 bytes.

= Usage into other game =
[[File:catchchallenger-base-into-other-game.png]]
See: [[Other game usage]]

= Compression =
The compression is used for datapack list/datapack content:
* Zlib: To save bandwidth at exchange of cpu
* Gzip: like Zlib but better ratio, and use more cpu
* lz4 by [[Lz4CompressionTcpSocket for Qt]]: Have very small cpu overhead, but worse compression ratio than zlib/gzip, lz4hc use few more cpu but remain with worse compression ratio than zlib/gzip.
* None: No compression overhead, but some query can use lot of bandwidth

See too: [[Quick Benchmark: Gzip vs Bzip2 vs LZMA vs XZ vs LZ4 vs LZO]]
