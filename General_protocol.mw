= Protocol content =
The used encoding is the unicode (utf16), where each char is encoded into 16Bits in big endian.

Firstly query type 8Bits to the first type and if needed 32Bits for the sub type, query number as short unsigned 8Bits (if query with reply), after the specific part.

= Cutting packet =
The tpc/ip protocol split the packet into lot of small packet. Warning, you need recompose the query.

= Messages composition =
{| class="wikitable" style="text-align: center; font-size: 85%; width: auto; table-layout: fixed;"
| style="background: #90ff90; color: black;" | Main code type
| style="background: #ffcc00; color: black;" | Sub code type (optional)
| style="background: #00E6FF; color: black;" | Packet size (for packet without fixed size)
| Packet content
|}

{{note}}: The packet size definition can varies:
* Mode small: Packet size with: XX if for <255 message size, 0000XXXX is for <64K size, 00000000XXXXXXXX if for the rest. (Interesting for raw protocol for 4x packet < 255Bytes than <64BKB)
* Mode big: Packet size with: 00XX if for <255 message size, XXXX is for <64K size, 00000000XXXXXXXX if for the rest. (Interesting for raw protocol for 4x packet < 255Bytes than <64BKB)
Choose do by server at the protocol initialization.

= Messages type =
[[Base protocol messages]]

== Specific to catchchallenger ==
query client -> server with reply
* '''020006''' Invite to the trade + push new object to the trade (with sell/buy too)
* '''020008''' Give bot craft recipe and object, and define the price + taxe

query client -> server without reply
* '''420004''' Fight attack/object used
* '''420005''' Usage of object

query server -> client with reply
* '''800001''' Battle request

= Latency =
* All the query with reply is identified by return code, then multiple query ca&n be send, it will never be blocking.
* Never ask the server reply because the reply is based on the random. '''A random list is used''' (and send by the server to the client), and both '''client and server do the calculate''' (minimize bandwidth, and not slow down)
* '''Send the previous step do and new direction'''. Then the server can check all move into one direction (more fast), and the request on the network is grouped. The client when receive the other player move, put the other player at the good position, and do moving at the right direction. With this, if latency is < a ms to do a step is always invisible. And if latency < at time to do all the step into a direction, is invisible too
* All the network traffic shouldn't be instant, then latency can be added to '''compress the data'''. Very useful because this protocol have high level of compression.
* All heavy '''task is isolated into a thread''' to not slow down the quick task

= Map position/move =
All is done to have multiple algorithm into the server, you can calculate that's by chunk of map, by map, or other way.

= Usage into other game =
[[File:catchchallenger-base-into-other-game.png]]
See: [[Other game usage]]

= Compression =
At the protocole supported or not reply, the server will send too the compression used, chunk size, and compression level. After this, the compression switch to the compression. The compression can be none.

The compression can be:
* Zlib: To save bandwidth at exchange of cpu
* Gzip: like Zlib but better ratio, and use more cpu
* lz4 by [[Lz4CompressionTcpSocket for Qt]]: Have very small cpu overhead, but worse compression ratio than zlib/gzip, lz4hc use few more cpu but remain with worse compression ratio than zlib/gzip.
* None: No compression overhead, but some query can use lot of bandwidth
Choose do by server at the protocol initialization.

It's compression for QTcpSocket/QSslSocket, and this compression can be hot added/removed. This class are adapted to streaming, that's: that's mean infinity volume, random data append, data re-composition, the data send at the compression is directly compressed and send (no wait more data to send). It's perfect to real time communication.

See too: [[Quick Benchmark: Gzip vs Bzip2 vs LZMA vs XZ vs LZ4 vs LZO]]
